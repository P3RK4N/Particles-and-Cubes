// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel MockInit
#pragma kernel MockTick
#pragma kernel MockEmit

#define GROUP_SIZE 32

static const int LOCAL_SPACE        = 0;
static const int GLOBAL_SPACE       = 1;

static const int RENDER_BILLBOARD   = 0;
static const int RENDER_POINT       = 1;
static const int RENDER_MESH        = 2;

static const int SCALAR_EXACT       = 0;
static const int SCALAR_RANGED      = 1;
static const int SCALAR_GAUSSIAN    = 2;

static const int FUNCTION_POINT     = 0;
static const int FUNCTION_SPHERE    = 1;
static const int FUNCTION_PLANE     = 2;
static const int FUNCTION_CUBOID    = 3;

static const int FALLOFF_ROOT       = 0;
static const int FALLOFF_LINEAR     = 1;
static const int FALLOFF_QUADRATIC  = 2;
static const int FALLOFF_CUBOID     = 3;

struct SimulationState
{
    float3  Position;
    float3  Scale;
    float3  Rotation;
    float3  Velocity;
    float3  ExternalVelocity;
    float3  Colour;
    float2  Current_Max_Life;
    int2    SimSpace_RendType;
};

RWStructuredBuffer<SimulationState> SimulationStateBuffer;

cbuffer GlobalState
{
    // Settings Stuff
    int Seed;
    int SimulationSpace;
    int RenderType;
    
    // Kernel Stuff
    int DISPATCH_NUM;
    int MAX_PARTICLE_COUNT;

    // Time Stuff
    float DeltaTime;
    float Time;

    // Environment Stuff
    float3 EmitterPositionWS;
    float GravityForce;
    
    // TODO: Expand existing ones
 
    // Lifetime
    int LifetimeScalarType;
    float ExactLifetime;
    float BottomLifetime;
    float TopLifetime;

    // Position
    int PositionFunctionType;
    float3 CenterOffset;
    float Radius;
    
    // Velocity
    int VelocityScalarType;
    float3 ExactVelocity;
    float3 BottomVelocity;
    float3 TopVelocity;
    
    // Scale
    int ScaleScalarType;
    int UniformScale;
    float3 ExactScale;
    float3 BottomScale;
    float3 TopScale;
    
    // Rotation
    int RotationScalarType;
    float3 ExactRotation;
    float3 BottomRotation;
    float3 TopRotation;
    
    // TODO: Expand new ones
}; 

RWStructuredBuffer<int>             CurrentParticleCountBuffer;
RWStructuredBuffer<int>             EmissionAmountCounterBuffer;

// TODO: Fix PRNG functions

/*
    ##############################################################
    ####################### RNG STUFF ############################
    ##############################################################
*/

// Time + Seed => float rand(float, ID)
float randTS(float x, int ID)
{
    float2 uv = float2(x, Time);
    uint hash = uint(uv.x * 43758.5453123 + uv.y * 76963.7543123 + float(Seed) + ID);
    hash = (hash << 13) ^ hash;
    hash = (hash * (hash * hash * 15731u + 789221u) + 1376312589u) & 0x7fffffffu;

    float random01 = float(hash) / float(0x7fffffff);
    return random01;
}

// Time + Seed => float3 rand(float3, ID)
float3 randTS(float3 input, int ID)
{
    float3 uvw = input + float3(Time, Time * 1.618033988749895, float(Seed + ID));

    // Combine uvw into a single hash
    uint hash = uint(uvw.x * 43758.5453123 + uvw.y * 76963.7543123 + uvw.z * 47113.7413123);
    hash = (hash << 13) ^ hash;
    hash = (hash * (hash * hash * 15731u + 789221u) + 1376312589u) & 0x7fffffffu;

    // Map the hash to a float3 in the range [0, 1)
    float3 random03 = float3(
        float(hash & 0xFFFF) / 65535.0f,
        float((hash >> 16) & 0xFFFF) / 65535.0f,
        float((hash >> 32) & 0xFFFF) / 65535.0f
    );

    return random03;
}

// float3 Gradient(float3)
float3 GradientNoise(float3 p, float time)
{
    p += float3(time, time * 0.5, time * 0.2);

    float3 i = floor(p);
    float3 f = frac(p);

    // Smooth interpolation function (e.g., cubic)
    float3 u = f * f * (3.0 - 2.0 * f);

    return lerp(
        lerp(
            lerp(randTS(i + float3(0, 0, 0), 1), randTS(i + float3(1, 0, 0), 1), u.x),
            lerp(randTS(i + float3(0, 1, 0), 1), randTS(i + float3(1, 1, 0), 1), u.x),
            u.y),
        lerp(
            lerp(randTS(i + float3(0, 0, 1), 1), randTS(i + float3(1, 0, 1), 1), u.x),
            lerp(randTS(i + float3(0, 1, 1), 1), randTS(i + float3(1, 1, 1), 1), u.x),
            u.y),
        u.z
    );
}

// RAND_VEC on unit sphere => modified: https://www.shadertoy.com/view/3djyWW
const float PI = 3.141592653;
#define FK(k) asuint(cos(k))^asuint(k)
float hash(float2 uv)
{
    int x = FK(uv.x);
    int y = FK(uv.y);
    return float((x * x + y) * (y * y - x) + x) / 2.14e9;
}

float3 randvec(float seed)
{
    float h1 = hash(float2(seed, seed));
    float h2 = hash(float2(h1, seed));
    float h3 = hash(float2(h2, seed));
    return normalize(float3(h1, h2, h3));
}


/*
    ##############################################################
    ##################### COMPUTE STUFF ##########################
    ##############################################################
*/


void ResetScale(uint ID)
{
    if(ScaleScalarType == SCALAR_EXACT)
    {
        SimulationStateBuffer[ID].Scale = ExactScale;
    }
    else if(ScaleScalarType == SCALAR_RANGED)
    {
        float3 prev = SimulationStateBuffer[ID].Scale;
        float3 diff = TopScale - BottomScale;
        float3 rand = UniformScale ? randTS(prev.x, ID) : randTS(prev, ID);
        SimulationStateBuffer[ID].Scale = BottomScale + diff * rand;
    }
    else
    {
        // TODO
    }
}

void ResetPosition(uint ID)
{
    float3 prev = SimulationStateBuffer[ID].Position;
                                        /* Zero if SimulationSpace == Local */
    float3 newPosition = CenterOffset + (SimulationSpace * EmitterPositionWS);

    if(PositionFunctionType == FUNCTION_POINT)
    {
        /* NOP */
    }
    else if(PositionFunctionType == FUNCTION_SPHERE)
    {
                       /* Offset From Middle of sphere at [0-Radius] */
        newPosition += randvec(hash(randTS(prev, ID).xy)) * Radius * randTS(prev.x, ID);
    }
    else
    {
        // TODO
    }
    
    SimulationStateBuffer[ID].Position = newPosition;
}

void ResetRotation(uint ID)
{
    if(RotationScalarType == SCALAR_EXACT)
    {
        SimulationStateBuffer[ID].Rotation = ExactRotation;
    }
    else if(RotationScalarType == SCALAR_RANGED)
    {
        float3 prev = SimulationStateBuffer[ID].Rotation;
        float3 diff = TopRotation - BottomRotation;
        float3 rand = UniformScale ? randTS(prev.x, ID) : randTS(prev, ID);
        SimulationStateBuffer[ID].Rotation = BottomRotation + diff * rand;
    }
    else
    {
        // TODO
    }
}

void ResetParticle(uint ID)
{
    ResetScale(ID);
    ResetPosition(ID);
    ResetRotation(ID);
    
    SimulationStateBuffer[ID].Velocity          = ExactVelocity;
    SimulationStateBuffer[ID].ExternalVelocity  = 0.0f;
    SimulationStateBuffer[ID].Colour            = GradientNoise(ID, Time);
    SimulationStateBuffer[ID].Current_Max_Life  = 1;
    SimulationStateBuffer[ID].SimSpace_RendType = int2(SimulationSpace, RenderType);
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MockInit(uint3 id : SV_DispatchThreadID)
{
    uint ID = id.x + id.y * DISPATCH_NUM * GROUP_SIZE;
    if((int)ID >= MAX_PARTICLE_COUNT) return;
    
    SimulationStateBuffer[ID].Current_Max_Life  = 0.0f;
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MockEmit(uint3 id : SV_DispatchThreadID)
{
    uint ID = id.x + id.y * DISPATCH_NUM * GROUP_SIZE;
    if
    (
        // Out of scope
        (int)ID                                      >= MAX_PARTICLE_COUNT ||
        
        // Not Dead Yet
        SimulationStateBuffer[ID].Current_Max_Life.x  > 0.0                ||

        // Max Particles Reached
        CurrentParticleCountBuffer[0]                == MAX_PARTICLE_COUNT

    ) return;
    
    
    int emissionIndex = EmissionAmountCounterBuffer.DecrementCounter();
    
    // Emitted enough already
    if(emissionIndex < 0) return;
    
    // Increment current particle amount
    CurrentParticleCountBuffer.IncrementCounter();
    
    ResetParticle(ID);
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MockTick(uint3 id : SV_DispatchThreadID)
{
    uint ID = id.x + id.y * DISPATCH_NUM * GROUP_SIZE;
    if
    (
        // Out of scope
        (int)ID                                      >= MAX_PARTICLE_COUNT ||

        // Dead
        SimulationStateBuffer[ID].Current_Max_Life.x <= 0.0
        
    ) return;

    // Age it
    SimulationStateBuffer[ID].Current_Max_Life.x -= DeltaTime;
    
    // Apply external force
    SimulationStateBuffer[ID].ExternalVelocity.y += GravityForce * DeltaTime;
    
    // Apply velocity
    SimulationStateBuffer[ID].Position += DeltaTime *
    (
        SimulationStateBuffer[ID].Velocity
        + SimulationStateBuffer[ID].ExternalVelocity
    );
    
    // Remove from the alive pool
    if (SimulationStateBuffer[ID].Current_Max_Life.x <= 0) CurrentParticleCountBuffer.DecrementCounter();
}
