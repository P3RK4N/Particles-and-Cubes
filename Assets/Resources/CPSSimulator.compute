// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel MockInit
#pragma kernel MockTick
#pragma kernel MockEmit

#define GROUP_SIZE 32

static const int LOCAL_SPACE        = 0;
static const int GLOBAL_SPACE       = 1;

static const int RENDER_BILLBOARD   = 0;
static const int RENDER_POINT       = 1;
static const int RENDER_MESH        = 2;

static const int SCALAR_EXACT       = 0;
static const int SCALAR_RANGED      = 1;
static const int SCALAR_GAUSSIAN    = 2;

static const int FUNCTION_POINT     = 0;
static const int FUNCTION_SPHERE    = 1;
static const int FUNCTION_PLANE     = 2;
static const int FUNCTION_CUBOID    = 3;

static const int FALLOFF_ROOT       = 0;
static const int FALLOFF_LINEAR     = 1;
static const int FALLOFF_QUADRATIC  = 2;
static const int FALLOFF_CUBOID     = 3;

struct SimulationState
{
    float3  Position;
    float3  Scale;
    float3  Rotation;
    float3  Velocity;
    float3  ExternalVelocity;
    float3  Colour;
    float2  Current_Max_Life;
    int2    SimSpace_RendType;
};

RWStructuredBuffer<SimulationState> SimulationStateBuffer;

cbuffer GlobalState
{
    // Settings Stuff
    int Seed;
    int SimulationSpace;
    int RenderType;
    
    // Kernel Stuff
    int DISPATCH_NUM;
    int MAX_PARTICLE_COUNT;

    // Time Stuff
    float DeltaTime;
    float Time;

    // Environment Stuff
    float3 EmitterPositionWS;
    float GravityForce;
    
    // TODO: Expand existing ones
 
    // Lifetime
    int LifetimeScalarType;
    float ExactLifetime;
    float BottomLifetime;
    float TopLifetime;

    // Position
    int PositionFunctionType;
    float3 CenterOffset;
    float Radius;
    
    // Velocity
    int VelocityScalarType;
    float3 ExactVelocity;
    float3 BottomVelocity;
    float3 TopVelocity;
    
    // Scale
    int ScaleScalarType;
    int UniformScale;
    float3 ExactScale;
    float3 BottomScale;
    float3 TopScale;
    
    // Rotation
    int RotationScalarType;
    float3 ExactRotation;
    float3 BottomRotation;
    float3 TopRotation;
    
    // TODO: Expand new ones
}; 

RWStructuredBuffer<int>             CurrentParticleCountBuffer;
RWStructuredBuffer<int>             EmissionAmountCounterBuffer;

float Hash(float3 p)
{
    float h = dot(p, float3(127.1, 311.7, 74.7));
    return frac(sin(h) * 43758.5453123);
}

float3 GradientNoise(float3 p, float time)
{
    p += float3(time, time * 0.5, time * 0.2);

    float3 i = floor(p);
    float3 f = frac(p);

    // Smooth interpolation function (e.g., cubic)
    float3 u = f * f * (3.0 - 2.0 * f);

    return lerp(
        lerp(
            lerp(Hash(i + float3(0, 0, 0)), Hash(i + float3(1, 0, 0)), u.x),
            lerp(Hash(i + float3(0, 1, 0)), Hash(i + float3(1, 1, 0)), u.x),
            u.y),
        lerp(
            lerp(Hash(i + float3(0, 0, 1)), Hash(i + float3(1, 0, 1)), u.x),
            lerp(Hash(i + float3(0, 1, 1)), Hash(i + float3(1, 1, 1)), u.x),
            u.y),
        u.z
    );
}

float rand(float co)
{
    return frac(sin(co * (91.3458)) * 47453.5453);
}

// Uses Time and Seed
float randTS(float x)
{
    float2 uv = float2(x, Time);
    uint hash = uint(uv.x * 43758.5453123 + uv.y * 76963.7543123 + float(Seed));
    hash = (hash << 13) ^ hash;
    hash = (hash * (hash * hash * 15731u + 789221u) + 1376312589u) & 0x7fffffffu;

    float random01 = float(hash) / float(0x7fffffff);
    return random01;
}

float3 randTS(float3 input)
{
    float3 uvw = input + float3(Time, Time * 1.618033988749895, float(Seed));

    // Combine uvw into a single hash
    uint hash = uint(uvw.x * 43758.5453123 + uvw.y * 76963.7543123 + uvw.z * 47113.7413123);
    hash = (hash << 13) ^ hash;
    hash = (hash * (hash * hash * 15731u + 789221u) + 1376312589u) & 0x7fffffffu;

    // Map the hash to a float3 in the range [0, 1)
    float3 random01 = float3(
        float(hash & 0xFFFF) / float(0xFFFF),
        float((hash >> 16) & 0xFFFF) / float(0xFFFF),
        float((hash >> 32) & 0xFFFF) / float(0xFFFF)
    );

    return random01;
}

float ResetScalar(float minScalar, float maxScalar)
{
    
}

float3 ResetScalar(float3 minScalar, float3 maxScalar)
{
    
}

void ResetScale(uint ID)
{
    if(ScaleScalarType == SCALAR_EXACT)
    {
        SimulationStateBuffer[ID].Scale = ExactScale;
    }
    else if(ScaleScalarType == SCALAR_RANGED)
    {
        float3 prev = SimulationStateBuffer[ID].Scale;
        float3 diff = TopScale - BottomScale;
        float3 rand = UniformScale ? randTS(prev.x) : randTS(prev);
        SimulationStateBuffer[ID].Scale = BottomScale + diff * rand;
    }
    else
    {
        // TODO
    }
}

void ResetPosition(uint ID)
{
                                                                      /* Zero if SimulationSpace == Local */
    SimulationStateBuffer[ID].Position          = ID + CenterOffset + (SimulationSpace * EmitterPositionWS);
}

void ResetRotation(uint ID)
{
    if(RotationScalarType == SCALAR_EXACT)
    {
        SimulationStateBuffer[ID].Rotation = ExactRotation;
    }
    else if(RotationScalarType == SCALAR_RANGED)
    {
        
    }
    else
    {
        // TODO
    }
}

void ResetParticle(uint ID)
{
    ResetScale(ID);
    ResetPosition(ID);
    ResetRotation(ID);
    
    SimulationStateBuffer[ID].Velocity          = ExactVelocity;
    SimulationStateBuffer[ID].ExternalVelocity  = 0.0f;
    SimulationStateBuffer[ID].Colour            = GradientNoise(ID, Time);
    SimulationStateBuffer[ID].Current_Max_Life  = 1;
    SimulationStateBuffer[ID].SimSpace_RendType = int2(SimulationSpace, RenderType);
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MockInit(uint3 id : SV_DispatchThreadID)
{
    uint ID = id.x + id.y * DISPATCH_NUM * GROUP_SIZE;
    if((int)ID >= MAX_PARTICLE_COUNT) return;
    
    SimulationStateBuffer[ID].Current_Max_Life  = 0.0f;
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MockEmit(uint3 id : SV_DispatchThreadID)
{
    uint ID = id.x + id.y * DISPATCH_NUM * GROUP_SIZE;
    if
    (
        // Out of scope
        (int)ID                                      >= MAX_PARTICLE_COUNT ||
        
        // Not Dead Yet
        SimulationStateBuffer[ID].Current_Max_Life.x  > 0.0                ||

        // Max Particles Reached
        CurrentParticleCountBuffer[0]                == MAX_PARTICLE_COUNT

    ) return;
    
    
    int emissionIndex = EmissionAmountCounterBuffer.DecrementCounter();
    
    // Emitted enough already
    if(emissionIndex < 0) return;
    
    // Increment current particle amount
    CurrentParticleCountBuffer.IncrementCounter();
    
    ResetParticle(ID);
}

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void MockTick(uint3 id : SV_DispatchThreadID)
{
    uint ID = id.x + id.y * DISPATCH_NUM * GROUP_SIZE;
    if
    (
        // Out of scope
        (int)ID                                      >= MAX_PARTICLE_COUNT ||

        // Dead
        SimulationStateBuffer[ID].Current_Max_Life.x <= 0.0
        
    ) return;

    // Age it
    SimulationStateBuffer[ID].Current_Max_Life.x -= DeltaTime;
    
    // Apply external force
    SimulationStateBuffer[ID].ExternalVelocity.y += GravityForce * DeltaTime;
    
    // Apply velocity
    SimulationStateBuffer[ID].Position += DeltaTime *
    (
        SimulationStateBuffer[ID].Velocity
        + SimulationStateBuffer[ID].ExternalVelocity
    );
    
    // Remove from the alive pool
    if (SimulationStateBuffer[ID].Current_Max_Life.x <= 0) CurrentParticleCountBuffer.DecrementCounter();
}
